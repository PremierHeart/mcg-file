#!/usr/bin/env ruby
# :title: Mpa::Diagnosis::Dgo
=begin rdoc
=Dgo Library
<i>(c) Copyright 2017 Premier Heart, LLC</i>
=end

module Mpa
  
  module Diagnosis

=begin rdoc
Diagnosis objects. This is a module supporting the DGO file format and
data structures originally written in C.

DGO is the output of a diagnosis algorithm. Each diagnosis has a value, a
status (positive or negative), and a list of references.
=end
    module Dgo

=begin rdoc
The value of a Diagnosis object. This encodes a type and size for use in calls
to Array#pack and String#unpack.
=end
      class Value
        attr_reader :type
        attr_accessor :data
        TYPES = ['o','c','C','s','S','i','I','l','L','f','d','a','r']
        TYPE_SIZES = [0,1,1,2,2,4,4,4,4,4,8,0,0]

        def initialize( type, data=0 )
          @type = type
          @data = data
        end

        def binary_datatype
          return TYPES.index(@type)
        end

        def type_size
          TYPE_SIZES[TYPES.index(@type)]
        end

        def data_size
          size = type_size
          if size == 0
            size = @data.length()
          end
          return size
        end

        def to_h
          { :type => @type, :data => @data }
        end

        def self.from_h(hash)
          hash ||= {}
          # convert string keys to symbols (JSON hack)
          h = hash.inject({}) { |h, (k,v)| h[k.to_sym] = v; h }
          self.new( h[:type], h[:data] )
        end

        def to_s
          @data.to_s
        end

        def inspect
          "(#{@type}) #{@data.to_s}"
        end

      end

=begin rdoc
A reference to a Dgo::Diagnosis object, a Sar::Index object, or a Sar::IntData
object which was used in calculating the value of a diagnosis. This is used
to trace the decisions made in calculation of a diagnosis.
=end
      class Ref
        attr_reader :type, :source, :component, :item
        attr_accessor :weight

        TYPE_SAR_INDEX = 'SAR index'
        TYPE_SAR_IDATA = 'SAR idata'
        TYPE_DGO_DIAG  = 'DGO diagnosis'

        TYPES = [ 'unknown', TYPE_SAR_INDEX, TYPE_SAR_IDATA, TYPE_DGO_DIAG ]

        DEFAULT_WEIGHT = 1.0

        def initialize( type, source, component, item, weight  )
          @type = type
          @source = source
          @component = component
          @item = item
          @weight = weight
        end

        def to_h
          { :type => @type, 
            :source => @source,
            :component => @component,
            :item => @item,
            :weight => @weight
          }
        end

        def self.from_h(hash)
          hash ||= {}
          # convert string keys to symbols (JSON hack)
          h = hash.inject({}) { |h, (k,v)| h[k.to_sym] = v; h }
          self.new( h[:type].to_s, h[:source].to_s, h[:component].to_s, 
                    h[:item].to_s, h[:weight] )
        end

        def to_s
          "(#{@type}) #{@source}.#{@component}.#{@item}"
        end

        def inspect
          "%s: %0.3f" % [self.to_s, @weight]
        end

      end

=begin rdoc
A diagnosis, or result, generated by analysis. This is usually a boolean value
(positive or negative) associated with a diagnosis name. In some cases, such
as weighted diagnoses, it makes sense to associate a value with the diagnosis,
and this is supported by using a Value object to represent the actual value
of the diagnosis.

Each Diagnosis object maintains a list of Ref objects (created by whichever 
code also created the Diagnosis object) which list Dgo::Diagnosis objects,
Sar::Index objects, or Sar::IntData objects which contributed to the diagnosis 
value. This creates a tree structure across analysis stages (index generation
and diagnosis generation) that can be used to trace the decisions made in
calculating a diagnosis value.

To access the value of a Diagnosis object, use Diagnosis#value#data.
=end
      class Diagnosis
        attr_reader :name, :sym
        attr_accessor :positive, :value, :refs

        SOURCE = ''       # Empty source for diagnosis objects (used in refs)
        POSITIVE = true   # True, false values for 'positive' field
        NEGATIVE = false

        def initialize( name, sym, positive, value )
          @refs = []
          @name = name
          @sym = sym 
          @positive = positive
          @value = value
        end

        def ref( type, source, component )
          @refs.each do |r| 
            return r if r.type == type and r.source == source and
                        r.component == component
          end
          return nil
        end

        def is_positive?  
          @positive
        end

=begin rdoc
Add a reference to the Diagnosis object with the provided attributes. 
Note that Ref target type must be specified.
=end
        def add_reference( type, source, component, name, weight=nil )
          r = Ref.new( type, source, component, name, 
                       weight ? weight : Ref::DEFAULT_WEIGHT  )
          add_reference_obj(r)
          return r
        end

=begin rdoc
Add a manually-created Ref object to the Diagnosis object.
WARNING: Only call this if you really need to.
=end
        def add_reference_obj(obj)
          @refs << obj
        end

=begin rdoc
Add a reference to the Diagnosis for a Sar::Index object.
=end
        def add_sar_index_ref( source, operation, name, weight=nil )
          add_reference( Ref::TYPE_SAR_INDEX, source, operation, name,
                         weight )
        end

=begin rdoc
Add a reference to the Diagnosis for a Sar::IntData object.
=end
        def add_sar_idata_ref( source, operation, name, weight=nil )
          add_reference( Ref::TYPE_SAR_IDATA, source, operation, name,
                         weight )
        end

=begin rdoc
Add a reference to the Diagnosis for a Dgo::Diagnosis object.
=end
        def add_dgo_diag_ref( algo, name, weight=nil )
          add_reference( Ref::TYPE_DGO_DIAG, SOURCE, algo, name, weight )
        end

        def to_h
          { :name => @name, 
            :sym => @sym,
            :positive => @positive,
            :value => @value.to_h,
            :refs => @refs.map { |ref| ref.to_h }
          }
        end

        def self.from_h(hash)
          hash ||= {}
          # convert string keys to symbols (JSON hack)
          h = hash.inject({}) { |h, (k,v)| h[k.to_sym] = v; h }
          obj = self.new( h[:name].to_s, h[:sym].to_s, h[:positive], 
                          Value.from_h(h[:value]) )
          h[:refs].each { |ref| obj.add_reference_obj( Ref.from_h ref ) }
          obj
        end

        def to_s
          "#{@name} (#{@sym})"
        end

        def inspect
          str = "\t\t#{self.to_s}\n"
          str << "\t\tPositive: #{@positive}\n"
          str << "\t\tValue: #{@value.inspect()}\n"
          str << "\t\tRefs:\n"
          @refs.each { |r| str << "\t\t\t#{r.inspect()}\n" }
          return str
        end

      end

=begin rdoc
A NULL object for diagnoses which do not exist.
The purpose of this is to allow the return value of Algorithm#diagnosis
to be referenced like a Diagnosis object, even when the specified diagnosis
was not found.
For clinical purposes, a NullDiagnosis is considered the same as a negative
Diagnosis. This may cause problems during debugging and testing, though. To
test for a 'missing' diagnosis:

  diag = algo.diagnosis( diag_name )
  raise "Missing '#{diag_name}' if diag.is_a? Mpa::Diagnosis::Dgo::NullDiagnosis
=end
      class NullDiagnosis
        attr_reader :name, :sym, :refs

        def initialize( name, sym )
          @name = name
          @sym = sym
          @refs = []
        end

        def value
          return Value.new('f')
        end

        def positive
          return false
        end

        def is_positive?  
          return false
        end

        # act like a nil, when asked
        def nil?
          true
        end

        def to_s
          "Null Diagnosis ('#{@name}')"
        end

        def inspect
          self.to_s
        end

      end

=begin rdoc
An analysis component which contains related Diagnoses. This is usually a
stage in Diagnosis (e.g. preliminary/primary/secondary/final), but it can 
be a standalone analysis component.
An Algorithm contains Diagnosis objects, which are stored in an Array (not
a Hash). This means that Diagnosis objects *need* not be unique (in terms
of name or symbol) within an Algorithm, but they *should* be unique in order
not to surprise users. Note that methods like Algorithm#diagnosis return
the first matching Diagnosis object.
=end
      class Algorithm
        attr_reader :name, :sym
        attr_accessor :diagnoses

        def initialize( name, sym )
          @diagnoses = []
          @name = name
          @sym = sym 
        end

        def include?( name )
          @diagnoses.each { |d| return true if d.name == name }
          false
        end

        def diagnosis( name )
          @diagnoses.each { |d| return d if d.name == name }
          return NullDiagnosis.new( name, name )
        end

        def diagnosis_sym( name )
          @diagnoses.each { |d| return d if d.sym == name }
          return NullDiagnosis.new( name, name )
        end

=begin rdoc
Add a diagnosis to the Algorithm with the specified attributes.
Note that diagnosis value and value-type must be provided.
=end
        def add_diagnosis( name, sym, positive, type, val )
          d = Diagnosis.new(name, sym, positive, Value.new(type, val))
          add_diagnosis_obj(d)
          return d
        end

=begin rdoc
Add a manually-created Diagnosis object to the Algorithm.
WARNING: Only call this if you really need to.
=end
        def add_diagnosis_obj(obj)
          @diagnoses << obj
        end

=begin rdoc
Add a diagnosis with a (signed) integer value
=end
        def add_diagnosis_i( name, sym, positive, val )
          add_diagnosis( name, sym, positive, 'i', val.to_i )
        end

=begin rdoc
Add a diagnosis with an unsigned integer value
=end
        def add_diagnosis_ui( name, sym, positive, val )
          add_diagnosis( name, sym, positive, 'I', val.to_i )
        end

=begin rdoc
Add a diagnosis with a floating-point value
=end
        def add_diagnosis_f( name, sym, positive, val )
          add_diagnosis( name, sym, positive, 'f', val.to_f )
        end

=begin rdoc
Add a diagnosis with a double floating-point value
=end
        def add_diagnosis_d( name, sym, positive, val )
          add_diagnosis( name, sym, positive, 'd', val.to_f )
        end

=begin rdoc
Add a diagnosis with a string value
=end
        def add_diagnosis_s( name, sym, positive, val )
          add_diagnosis( name, sym, positive, 'a', val.to_s )
        end
        
=begin rdoc
Add a diagnosis containing the patient age group.
=end
        def add_age_group( grp )
          # NOTE: Age Group diagnosis is never 'positive'
          add_diagnosis_i( Diagnosis::AGEGRP_NAME, Diagnosis::AGEGRP_SYM, 
                           false, grp.to_i )
        end

        def to_h
          { :name => @name, 
            :sym => @sym,
            :diagnoses => @diagnoses.map { |diag| diag.to_h }
          }
        end

        def self.from_h(hash)
          # convert string keys to symbols (JSON hack)
          h = hash.inject({}) { |h, (k,v)| h[k.to_sym] = v; h }
          obj = self.new( h[:name].to_s, h[:sym].to_s )
          (h[:diagnoses] || []).each do |d| 
            obj.add_diagnosis_obj( Diagnosis.from_h d )
          end
          obj
        end

        def to_s
          "#{@name} (#{@sym})"
        end

        def inspect
          str = "\t#{self.to_s}\n\tDiagnoses:\n" 
          @diagnoses.each { |d| str << d.inspect() + "\n" }
          str << "\n"
          return str
        end

      end

=begin rdoc
DGO object. Originally the in-memory representation of a DGO file, this
represents the diagnosis output of a complete analysis run.

A Dgo consists of analysis components called algorithms; these can be 
considered stages of analysis. An Algorithm object is a named collection 
of Diagnosis objects; each Diagnosis has a Value and an optional collection 
of references (Ref objects) to Dgo Diagnoses or Sar Indexes/IntData.

Note that Algorithm objects are stored in an Array, not a Hash.
=end
      class Dgo
        attr_accessor :algorithms, :timestamp

        def initialize( timestamp=Time.now.to_i() )
          @algorithms = []
          @timestamp = timestamp
        end

        def add_algorithm_obj(obj)
          @algorithms << obj
        end

        def include?( name )
          @algorithms.select { |a| a.name == name }.count > 0
        end

        def algorithm( name )
          @algorithms.select { |a| a.name == name }.first
        end

        def algorithm_sym( sym )
          @algorithms.select { |a| a.sym == sym }.first
        end

=begin rdoc
Return an Algorithm object for the specified name and sym. If an Algorithm 
already exists for name, it will be returned; otherwise, a new Algorithm object
is created.
=end
        def get_or_create_algorithm(name, sym)
          a = @algorithms.select { |a| a.name == name }.first
          if ! a
            a = Algorithm.new(name, sym)
            add_algorithm_obj(a)
          end

          a
        end

=begin rdic
Return a Diagnosis object for the specified algorithm and diagnosis. Note that
either a name or a symbol can be provided for the Diagnosis and Algorithm.
=end
        def algorithm_diag( algo_name, diag_name )
          algo = algorithm(algo_name)
          algo ||= algorithm_sym(algo_name)
          return if not algo
          diag = algo.diagnosis(diag_name)
          diag = algo.diagnosis_sym(diag_name) if diag.is_a? NullDiagnosis
          diag
        end

=begin rdoc
Convert to a Hash object, e.g. for JSON serialization.
=end
        def to_h
          { :timestamp => @timestamp, 
            :algorithms => @algorithms.map { |algo| algo.to_h }
          }
        end

=begin rdoc
Instantiate from a Hash object, e.g. for de-serialization from JSON.
=end
        def self.from_h(hash)
          # convert string keys to symbols (JSON hack)
          h = hash.inject({}) { |h, (k,v)| h[k.to_sym] = v; h }
          obj = self.new( h[:timestamp] )
          (h[:algorithms] || []).each do |a| 
            obj.add_algorithm_obj(Algorithm.from_h a) 
          end
          obj
        end

        # ASCII representation of DGO contents
        def to_s
          "DGO (Diagnosis output) from #{Time.at(@timestamp).to_s}"
        end
        
        # ASCII representation of DGO contents
        def inspect
          str = self.to_s
          str << "\n-------------------------------------------------------\n"
          str << "Algorithms:\n"
          @algorithms.each do |a|
            str << a.inspect()
          end

          return str
        end

      end

    end
  end
end


if __FILE__ == $0 
  dgo = Mpa::Diagnosis::Dgo::Dgo.new()

  dgo.algorithms << Mpa::Diagnosis::Dgo::Algorithm.new('Test Algo 1', 'TST1')
  dgo.algorithm('Test Algo 1').diagnoses << Mpa::Diagnosis::Dgo::Diagnosis.new(
            'Test 1 Diagnosis', 'TDG1', false, 
            Mpa::Diagnosis::Dgo::Value.new('i', 0) )
  a = Mpa::Diagnosis::Dgo::Algorithm.new('Diag Algo', 'DIAG')
  dgo.algorithms << a
  a.diagnoses << Mpa::Diagnosis::Dgo::Diagnosis.new( 'Diagnosis 1', 'DG1', true,
            Mpa::Diagnosis::Dgo::Value.new('f', 1.0) )
  a.diagnoses << Mpa::Diagnosis::Dgo::Diagnosis.new( 'Diagnosis 2', 'DG2',false,
            Mpa::Diagnosis::Dgo::Value.new('f', 0.0) )
  d =  Mpa::Diagnosis::Dgo::Diagnosis.new( 'Diagnosis 3', 'DG3', true, 
            Mpa::Diagnosis::Dgo::Value.new('i', 1) )
  a.diagnoses << d
  d.refs << Mpa::Diagnosis::Dgo::Ref.new( Mpa::Diagnosis::Dgo::Ref::TYPES[3], 
        '', 'Test Algo 1', 'Test 1 Diagnosis', 0.03 )
  d.refs << Mpa::Diagnosis::Dgo::Ref.new( Mpa::Diagnosis::Dgo::Ref::TYPES[1], 
        'V5', 'Auto Power Spectrum', 'FF', 0.12 )

  puts dgo
end
